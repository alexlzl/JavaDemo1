package com.test;

/**
 * Created by liuzhouliang on 2018/1/23.
 * <p>
 * 对于多态，可以总结以下几点：
 * 一、使用父类类型的引用指向子类的对象；
 * 二、该引用只能调用父类中定义的方法和变量；
 * 三、如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）
 * 四、变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。
 * <p>
 * java 的这种机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。
 * <p>
 * 记住一个很简单又很复杂的规则，一个类型引用只能引用引用类型自身含有的方法和变量。
 * 你可能说这个规则不对的，因为父类引用指向子类对象的时候，最后执行的是子类的方法的。
 * 其实这并不矛盾，那是因为采用了后期绑定，动态运行的时候又根据型别去调用了子类的方法。而假若子类的这个方法在父类中并没有定义，则会出错。
 */
public class PolymorphismTest {
    public static void main(String[] args) {
        Father child = new Child();
        child.func1();//打印结果将会是什么？
        /**
         * 在向下转型过程中，分为两种情况：

         情况一：如果父类引用的对象如果引用的是指向的子类对象，那么在向下转型的过程中是安全的。也就是编译是不会出错误的。

         情况二：如果父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现java.lang.ClassCastException错误。它可以使用instanceof来避免出错此类错误。实例如下：
         */
//        Child child1= (Child) new Father();//如果父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现java.lang.ClassCastException错误
//        child1.func1(100);
        Child child1 = (Child) child;//如果父类引用的对象如果引用的是指向的子类对象，那么在向下转型的过程中是安全的。也就是编译是不会出错误的
        child1.func1(100);
    }
}
